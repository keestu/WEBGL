<!--
    WEBGL Tutorial 4 Final
    Copyright (C) 2015  Tappali Ekanathan Keestu (keestu@gmail.com)
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>
    <head>
        <title>WEB GL Tutorial 4</title>
        <meta http-equiv="content-type" content="text/html; charset=utf-8">

        <!-- GL Matrix version 3.4.4 https://github.com/toji/gl-matrix/ -->
        <script type="text/javascript" src="gl-matrix/gl-matrix-min.js"></script>

        <!-- Google GL utility -->
        <script type="text/javascript" src="commonjs/webgl-utils.js"></script>

        <!-- CommonJS          -->
        <script type="text/javascript" src="commonjs/commonJS.js"></script>

        <!-- Frames per second -->
        <script type="text/javascript" src="commonjs/fps.js"></script>
        
        <!-- Mouse Location    -->
        <script type="text/javascript" src="commonjs/mouseLoc.js"></script>

        <!-- Key Press         -->
        <script type="text/javascript" src="commonjs/keyBoardEvents.js"></script>

        <!-- Camera            -->
        <script type="text/javascript" src="commonjs/camera.js"></script>

        <!-- JS color          -->
        <script type="text/javascript" src="jscolor/jscolor.js"></script>

        <!--   Shaders              -->
        <!--   Triangle Shader      -->
        <script id="triangle-shader-fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec4 vColor;

            void main(void) {
                gl_FragColor = vColor;
                }
        </script>

        <script id="triangle-shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec4 aVertexColor;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            varying vec4 vColor;

            void main(void) {
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vColor      = aVertexColor;
                }
        </script>

        <!--   Square Shader      -->
        <script id="square-shader-fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec4 vColor;

            void main(void) {
                gl_FragColor = vColor;
                }
        </script>

        <script id="square-shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec4 aVertexColor;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            varying vec4 vColor;

            void main(void) {
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vColor      = aVertexColor;
                }
        </script>

        <!--   Square Texture Shader      -->
        <script id="squareTex-shader-fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec2 vTextureCoord;
            uniform sampler2D uSampler;

            void main(void) {
                gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
                }
        </script>

        <script id="squareTex-shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec2 aTextureCoord;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            varying vec2 vTextureCoord;

            void main(void) {
                gl_Position   = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vTextureCoord = aTextureCoord;
                }
        </script>

        <!--   Square Light Texture Shader      -->
        <script id="squareLightTex-shader-fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec2 vTextureCoord;
            varying vec3 vLightWeighting;

            uniform sampler2D uSampler;

            void main(void) {
                vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
                gl_FragColor      = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
                }
        </script>

        <script id="squareLightTex-shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;
            uniform mat3 uNMatrix;

            uniform vec3 uAmbientColor;

            uniform vec3 uLightingDirection;
            uniform vec3 uDirectionalColor;

            uniform bool uUseLighting;

            varying vec2 vTextureCoord;
            varying vec3 vLightWeighting;

            void main(void) {
                gl_Position   = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vTextureCoord = aTextureCoord;

                if (uUseLighting) {
                    vec3 transformedNormal          = uNMatrix * aVertexNormal;
                    float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
                    vLightWeighting                 = uAmbientColor + uDirectionalColor * directionalLightWeighting;
                    }
                else {
                    vLightWeighting = vec3(0.0, 0.0, 0.0);
                    }
                }
        </script>

        <!--   Cube Shader      -->
        <script id="cube-shader-fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec4 vColor;

            void main(void) {
                gl_FragColor = vColor;
                }
        </script>

        <script id="cube-shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec4 aVertexColor;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            varying vec4 vColor;

            void main(void) {
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vColor      = aVertexColor;
                }
        </script>

        <!--   Cube Texture Shader      -->
        <script id="cubeTex-shader-fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec2 vTextureCoord;
            uniform sampler2D uSampler;

            void main(void) {
                gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
                }
        </script>

        <script id="cubeTex-shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec2 aTextureCoord;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            varying vec2 vTextureCoord;

            void main(void) {
                gl_Position   = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vTextureCoord = aTextureCoord;
                }
        </script>

        <!--   Cube Light Texture Shader      -->
        <script id="cubeLightTex-shader-fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec2 vTextureCoord;
            varying vec3 vLightWeighting;

            uniform sampler2D uSampler;

            void main(void) {
                vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
                gl_FragColor      = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
                }
        </script>

        <script id="cubeLightTex-shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;
            uniform mat3 uNMatrix;

            uniform vec3 uAmbientColor;

            uniform vec3 uLightingDirection;
            uniform vec3 uDirectionalColor;

            uniform bool uUseLighting;

            varying vec2 vTextureCoord;
            varying vec3 vLightWeighting;

            void main(void) {
                gl_Position   = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vTextureCoord = aTextureCoord;

                if (uUseLighting) {
                    vec3 transformedNormal          = uNMatrix * aVertexNormal;
                    float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
                    vLightWeighting                 = uAmbientColor + uDirectionalColor * directionalLightWeighting;
                    }
                else {
                    vLightWeighting = vec3(0.0, 0.0, 0.0);
                    }
                }
        </script>

        <!--   Pyramid Shader      -->
        <script id="pyramid-shader-fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec4 vColor;

            void main(void) {
                gl_FragColor = vColor;
                }
        </script>

        <script id="pyramid-shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec4 aVertexColor;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            varying vec4 vColor;

            void main(void) {
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vColor      = aVertexColor;
                }
        </script>

        <script type="text/javascript">
            /* Common sense to object disposition                */
            var objListToDispose   = new Array();

            /* On-page debug panel for WebGL/log output */
            (function(){
                // Create debug panel element once
                function ensureDebugPanel() {
                    if (document.getElementById('glDebug')) return document.getElementById('glDebug');
                    try {
                        var d              = document.createElement('div');
                        d.id               = 'glDebug';
                        d.style.position   = 'fixed';
                        d.style.right      = '8px';
                        d.style.bottom     = '8px';
                        d.style.maxHeight  = '30vh';
                        d.style.overflow   = 'auto';
                        d.style.background = 'rgba(0,0,0,0.75)';
                        d.style.color      = 'white';
                        d.style.fontFamily = 'monospace';
                        d.style.fontSize   = '12px';
                        d.style.padding    = '6px';
                        d.style.zIndex     = 9999;
                        d.style.width      = '38vw';
                        d.style.boxShadow  = '0 0 8px rgba(0,0,0,0.6)';

                        var title                = document.createElement('div');
                        title.textContent        = 'WebGL Debug';
                        title.style.fontWeight   = 'bold';
                        title.style.marginBottom = '6px';
                        d.appendChild(title);

                        var content              = document.createElement('div');
                        content.id               = 'glDebugContent';
                        d.appendChild(content);

                        // append when DOM ready
                        document.addEventListener('DOMContentLoaded', function(){ document.body.appendChild(d); });

                        // if DOM already ready
                        if (document.readyState === 'complete' || document.readyState === 'interactive') {
                            document.body.appendChild(d);
                            return d;
                            }
                        }
                    catch (e) {
                        return null;
                        }
                }

                // Wrap the existing printLog so page logs also go to the panel
                try {
                    var _oldPrintLog = window.printLog || function(m){ console.log(m); };
                    window.printLog = function(msg) {
                        try { _oldPrintLog(msg); } catch (e) { console.log(msg); }
                        try {
                            var panel = ensureDebugPanel();
                            if (!panel) return;
                            var content = document.getElementById('glDebugContent');
                            if (!content) return;
                            var line = document.createElement('div');
                            line.textContent = String(msg);
                            content.appendChild(line);
                            // keep scroll at bottom
                            content.scrollTop = content.scrollHeight;
                        } catch (e) { /* best-effort only */ }
                    };
                } catch (e) { /* ignore */ }
            })();

            /* Because all browsers don't like each other for fps*/
            var framesPerSecObject = defineFPSObject();
            objListToDispose[objListToDispose.length] = framesPerSecObject;

            /* Because JavaScript is third class in mouse events */
            var mouseLoc           = defineMouseLocationObject();
            objListToDispose[objListToDispose.length] = mouseLoc;

            /* Because JavaScript gives me no game options       */
            var keyboardPress      = defineKeyBoardObject();
            objListToDispose[objListToDispose.length] = keyboardPress;

            /* Need to stop the redraw when disposing            */
            var reDrawID = 0;

            /* Need an iterator in many places                   */
            var looper = 0;

            /* Need the redraw iterator to be initialized once   */
            /* Do not use elsewhere                              */
            var drawLooper = 0;

            /*****************************************************/
            /* WebGL start                                       */

            /* Base environment property for totality of WEBGL   */
            function defineWebGLPocket(canvas) {
                printLog("      Define the WEBGL base pocket");
                var basePocket = new Object();

                /* Constructor for a particular GL environment   */
                /* None as of now                                */

                /* Initialize WebGL                              */
                try {
                    var gl = WebGLUtils.setupWebGL(canvas);
                    if (!gl) {
                        printLog("      WEBGL not available (setupWebGL returned null)");
                        return basePocket;
                    }
                    gl.viewportWidth      = canvas.width;
                    gl.viewportHeight     = canvas.height;
                    basePocket.gl         = gl;
                    basePocket.depthField = 90;
                    printLog("      WEBGL base pocket: SUCCESS");
                }
                catch (e) {
                    /* Exception: Could not initialise WebGL     */
                    printLog("      Exception in WEBGL base pocket: " + e);
                    return basePocket;
                }

                /* Destructor                                    */
                basePocket.destroy = function() {
                    try {
                        if (this.gl) {
                            try {
                                var loseExt = this.gl.getExtension && this.gl.getExtension('WEBGL_lose_context');
                                if (loseExt && typeof loseExt.loseContext === 'function') {
                                    loseExt.loseContext();
                                    printLog('WEBGL context requested to be lost for cleanup');
                                }
                            } catch (e) {}
                        }
                    } catch (e) {}
                    this.gl = null;
                    this.depthField = null;
                    };

                return basePocket;
                }

            function definePocket(canvas) {
                printLog("    Define the pocket");
                var pocket      = new Object();

                /*    Constructor for a pocket                   */
                pocket.pocketGL = new defineWebGLPocket(canvas);

                /*    Exit if WEBGL could not initialize         */
                if ("undefined" == typeof pocket.pocketGL.gl) {
                    printLog("    Exception in Base pocket creation");
                    delete this.pocketGL;
                    delete this;
                    return 0;
                    }
                else {
                    printLog("    Setting WEBGL base attributes");
                    pocket.pocketGL.gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    }

                /* Set the base attributes for the camera        */
                pocket.camera = defineCamera(pocket);

                /* Complete declarations if pending              */
                pocket.pMatrix       = glMatrix.mat4.create();
                pocket.mvMatrixStack = new Array();

                /* Contents of the pocket                        */
                pocket.contentList   = new Array();

                /* Keep track of textures                        */
                pocket.texCount           = 0;

                /* Assign to the garbage collector object        */
                objListToDispose[objListToDispose.length] = pocket;

                /*************************************************/
                /*             Pocket base functions             */

                /* Get the fragment or vertex shader             */
                pocket.getShader = function(gl, id) {
                    printLog("          Get the Shader");
                    printLog("            Creating Shader:" + id);
                    var shaderScript = document.getElementById(id);
                    var shader;
                    var progInAString = "";

                    if (shaderScript) {
                        /* Use textContent which is robust for shader script contents */
                        progInAString = shaderScript.textContent;

                        if ("x-shader/x-fragment" == shaderScript.type) {
                            printLog("            Creating fragment shader");
                            shader = gl.createShader(gl.FRAGMENT_SHADER);
                            }
                        else if ("x-shader/x-vertex" == shaderScript.type) {
                            printLog("            Creating vertex shader");
                            shader = gl.createShader(gl.VERTEX_SHADER);
                            }
                        else {
                            return 0;
                            }

                        gl.shaderSource(shader, progInAString);
                        /* Keep the source on the shader object for diagnostics */
                        shader._source = progInAString;
                        gl.compileShader(shader);

                        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                            printLog("            Shader Program compile success");
                            return shader;
                            }
                        else {
                            var log = gl.getShaderInfoLog(shader);
                            printLog("            Shader Program compile failed: " + log);
                            try {
                                if (shader._source) {
                                    // print small numbered snippet of source
                                    var lines = shader._source.split(/\r?\n/);
                                    var maxLines = Math.min(lines.length, 200);
                                    printLog('            --- shader source (first ' + maxLines + ' lines) ---');
                                    for (var ii=0; ii<maxLines; ii++) {
                                        var ln = (ii+1) + ': ' + lines[ii];
                                        printLog('            ' + ln);
                                    }
                                    printLog('            --- end shader source ---');
                                    }
                                }
                            catch (e) {}
                                return 0;
                            }
                        }
                    else {
                        printLog("            Shader Program creation failed");
                        return 0;
                        }
                    };

                /* Initialize shader fragment                    */
                pocket.initShaders = function(gl, fragment, vertex) {
                    printLog("      Initialize Shader");
                    printLog("        Fragment Shader:" + fragment);
                    printLog("        Vertex Shader:" + vertex);

                    var fragmentShader = this.getShader(gl, fragment);
                    var vertexShader   = this.getShader(gl, vertex);

                    if (0 == fragmentShader || 0 == vertexShader) {
                        printLog("        Failed to Load shader");
                        return 0;
                        }
                    else {
                        var shaderProgram = gl.createProgram();
                        printLog("        Creating Shader fragment");
                        gl.attachShader(shaderProgram, vertexShader);
                        gl.attachShader(shaderProgram, fragmentShader);
                        gl.linkProgram(shaderProgram);

                        if (gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                            printLog("          Returning Shader fragment successfully");
                            gl.useProgram(shaderProgram);

                            var loc;
                            loc = gl.getAttribLocation(shaderProgram, "aVertexPosition");
                            if (loc >= 0) {
                                shaderProgram.vertexPositionAttribute = loc;
                                gl.enableVertexAttribArray(loc);
                            }

                            loc = gl.getAttribLocation(shaderProgram, "aVertexColor");
                            if (loc >= 0) {
                                shaderProgram.vertexColorAttribute = loc;
                                gl.enableVertexAttribArray(loc);
                            }

                            loc = gl.getAttribLocation(shaderProgram, "aTextureCoord");
                            if (loc >= 0) {
                                shaderProgram.textureCoordAttribute = loc;
                                gl.enableVertexAttribArray(loc);
                            }

                            loc = gl.getAttribLocation(shaderProgram, "aVertexNormal");
                            if (loc >= 0) {
                                shaderProgram.vertexNormalAttribute = loc;
                                gl.enableVertexAttribArray(loc);
                            }

                            shaderProgram.pMatrixUniform  = gl.getUniformLocation(shaderProgram, "uPMatrix");
                            shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");

                            var uLoc = gl.getUniformLocation(shaderProgram, "uNMatrix");
                            if (uLoc !== null) shaderProgram.nMatrixUniform = uLoc;

                            uLoc = gl.getUniformLocation(shaderProgram, "uSampler");
                            if (uLoc !== null) shaderProgram.samplerUniform = uLoc;

                            uLoc = gl.getUniformLocation(shaderProgram, "uUseLighting");
                            if (uLoc !== null) shaderProgram.useLightingUniform = uLoc;

                            uLoc = gl.getUniformLocation(shaderProgram, "uAmbientColor");
                            if (uLoc !== null) shaderProgram.ambientColorUniform = uLoc;

                            uLoc = gl.getUniformLocation(shaderProgram, "uLightingDirection");
                            if (uLoc !== null) shaderProgram.lightingDirectionUniform = uLoc;

                            uLoc = gl.getUniformLocation(shaderProgram, "uDirectionalColor");
                            if (uLoc !== null) shaderProgram.directionalColorUniform = uLoc;

                            /* For destroying properly           */
                            shaderProgram.fragmentShader  = fragmentShader;
                            shaderProgram.vertexShader    = vertexShader;

                            return shaderProgram;
                            }
                        else {
                            var info = gl.getProgramInfoLog(shaderProgram);
                            printLog("          Returning Shader fragment failed: " + info);
                            /* Also print shader compile logs when available */
                            try {
                                var vInfo = gl.getShaderInfoLog(vertexShader) || '';
                                var fInfo = gl.getShaderInfoLog(fragmentShader) || '';
                                if (vInfo) printLog('            Vertex shader log: ' + vInfo);
                                if (fInfo) printLog('            Fragment shader log: ' + fInfo);
                            } catch (e) {}
                            return 0;
                            }
                        }
                    };

                /* Handle loading textures                       */
                pocket.handleLoadedTexture = function(texture, gl) {
                    printLog("        Load Texture");
                    gl.bindTexture  (gl.TEXTURE_2D, texture);
                    gl.pixelStorei  (gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    try {
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
                        }
                    catch(err) {
                        printLog("            " + err.message);
                        printLog("            Loading Dummy image");
                        texture.image.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAABGdBTUEAALGPC/" +
                          "xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC4zjOaXUAAAAiFJREFUaEPtlFtywjAMRfnovrsT/" +
                          "llleqkYjytbtl6OaZszGgZILOlIgdvxy7kEdnMJ7OYS2I1T4H6/"+
                          "f36DN6+vvART2QRKsePjVoK+sZbPSqUVoHp1sTaUtRNTAZXAM1dTQ4px4cRUxFygWxITKrBLCKlwYqrCRKAtiTIsKT62tdvCialqJgIs3SBX21998/"+
                          "gqw3TzSIAlGmQhpMLS9wPYkeccBUYC9fgHKWq6hfVrrGGppFOigPJ8Czvo657QTFAU0ByWYE2XiOSRzqoETGMDbAklgnm6x/"+
                          "sC9Unr2IjaPytPN0NfYHpsSrsE6/iJbQLgnCQLBTByyoNX3/jBtJOFAsTj8Xi9c7FfIMh/FWD/"+
                          "Ie4nOE4t0G2jLwDeYQn1HKUe3lpA08PfFXiHn0EtIDUgCoC9S9D8AMD7CiirjwQ2PkX60iMBsGsJ+"+
                          "roTgS1LMBWdCIDzl2CqOBc4eQnWcnMBUI9Ek9QN616zcJWAI68Px6RUAoA5rFiCr4RWACx9kFj3+"+
                          "iUbBFgNRJZDJLNBAKxwCOa0CYBch3g2swDIckjJ4xEA8dop3QOnAIh0kNU98AuAtg/"+
                          "8/Y1bwVX2d4xwdw9CAqB1QEgNmW5WEhUAmrbwsR08Itg9SBAA3f7K4/R8/XmJIt49yBEguo12B1/"+
                          "c4mQKALTV7biOrNaJZAGiuwpE4uALSwQAW8WK1olVAgRpLGqdWCtwApfAbi6B3VwCezmOLxNwnYmgPOr4AAAAAElFTkSuQmCC";
                        }
                    };

                /* Initialize the texture                        */
                pocket.initTexture = function(gl,src) {
                    printLog("      Initialize Texture");
                    var texture       = gl.createTexture();
                    texture.image = new Image();
                    texture.image.onload = function () {
                        pocket.handleLoadedTexture(texture, gl);
                        };
                    texture.image.src = src;
                    return texture;
                    };

                pocket.setDepthBlend = function(depthBlendOption,depthParam,blendParamSrc,blendParamDest) {
                    if ("depth" == depthBlendOption) {
                        /*  Depth options
                            NEVER, ALWAYS
                            LESS,  GREATER
                            EQUAL, LEQUAL, NOTEQUAL, GEQUAL
                        */
                        this.pocketGL.gl.disable(this.pocketGL.gl.BLEND);
                        this.pocketGL.gl.enable(this.pocketGL.gl.DEPTH_TEST);
                        var depthEnum = this.pocketGL.gl[depthParam];
                        if (typeof depthEnum !== 'undefined') this.pocketGL.gl.depthFunc(depthEnum);
                        }

                    if ("blend" == depthBlendOption) {
                        /*  Blend options
                            ZERO, ONE
                            SRC_COLOR,  DST_COLOR
                            ONE_MINUS_SRC_COLOR, ONE_MINUS_DST_COLOR
                            SRC_ALPHA, DST_ALPHA
                            ONE_MINUS_SRC_ALPHA, ONE_MINUS_DST_ALPHA
                            SRC_ALPHA_SATURATE
                        */
                        this.pocketGL.gl.disable(this.pocketGL.gl.DEPTH_TEST);
                        this.pocketGL.gl.enable(this.pocketGL.gl.BLEND);
                        var srcEnum = this.pocketGL.gl[blendParamSrc];
                        var dstEnum = this.pocketGL.gl[blendParamDest];
                        if (typeof srcEnum !== 'undefined' && typeof dstEnum !== 'undefined') this.pocketGL.gl.blendFunc(srcEnum, dstEnum);
                        }

                    if ("none" == depthBlendOption) {
                        this.pocketGL.gl.disable(this.pocketGL.gl.DEPTH_TEST);
                        this.pocketGL.gl.disable(this.pocketGL.gl.BLEND);
                        }
                    };

                /* Tell WebGL the attributes not to be used      */
                pocket.disableUnusedAttr = function(gl,vertLimit) {
                    /* position, color, texture and normals (indices 0..3) */
                    for (var i = vertLimit; i < 4; i++) {
                        gl.disableVertexAttribArray(i);
                        }
                    };

                /* Push Matrix                                   */
                pocket.mvPushMatrix = function(mvMatrix, mvMatrixStack) {
                    var copy = glMatrix.mat4.create();
                    /* gl-matrix: mat4.copy(out, a) */
                    glMatrix.mat4.copy(copy, mvMatrix);
                    mvMatrixStack.push(copy);
                    };

                /* Pop Matrix                                    */
                pocket.mvPopMatrix = function(mvMatrix, mvMatrixStack) {
                    if (mvMatrixStack.length == 0) {
                        printLog("Invalid popMatrix");
                        }
                    var popped = mvMatrixStack.pop();
                    if (popped) {
                        glMatrix.mat4.copy(mvMatrix, popped);
                        }
                    };

                /* Set uniform Matrix                            */
                pocket.setMatrixUniforms = function(object,pMatrix) {
                    this.pocketGL.gl.uniformMatrix4fv(object.shaderProgram.pMatrixUniform, false, pMatrix);
                    this.pocketGL.gl.uniformMatrix4fv(object.shaderProgram.mvMatrixUniform, false, object.mvMatrix);

                    if (object.vertexNormalBuffer && object.shaderProgram.nMatrixUniform) {
                        var normalMatrix = glMatrix.mat3.create();
                        /* normalFromMat4 computes the inverse transpose of the 3x3 normal matrix */
                        glMatrix.mat3.normalFromMat4(normalMatrix, object.mvMatrix);
                        this.pocketGL.gl.uniformMatrix3fv(object.shaderProgram.nMatrixUniform, false, normalMatrix);
                    }
                    };

                /* Set the vertex position                       */
                pocket.setVertexPosition = function(object) {
                    if (object.vertexPositionBuffer){
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexPositionBuffer);
                        this.pocketGL.gl.vertexAttribPointer(object.shaderProgram.vertexPositionAttribute, object.vertexPositionBuffer.itemSize, this.pocketGL.gl.FLOAT, false, 0, 0);
                        this.pocketGL.gl.enableVertexAttribArray(object.shaderProgram.vertexPositionAttribute);
                        return 1;
                        }
                    return 0;
                    };

                /* Set the vertex color                          */
                pocket.setVertexColor = function(object) {
                    if (object.vertexColorBuffer) {
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexColorBuffer);
                        this.pocketGL.gl.vertexAttribPointer(object.shaderProgram.vertexColorAttribute, object.vertexColorBuffer.itemSize, this.pocketGL.gl.FLOAT, false, 0, 0);
                        this.pocketGL.gl.enableVertexAttribArray(object.shaderProgram.vertexColorAttribute);
                        return 1;
                        }
                    return 0;
                    };

                /* Set the normals                       */
                pocket.setVertexNormal = function(object) {
                    if (object.vertexNormalBuffer) {
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexNormalBuffer);
                        this.pocketGL.gl.vertexAttribPointer(object.shaderProgram.vertexNormalAttribute, object.vertexNormalBuffer.itemSize, this.pocketGL.gl.FLOAT, false, 0, 0);
                        this.pocketGL.gl.enableVertexAttribArray(object.shaderProgram.vertexNormalAttribute);
                        return 1;
                        }
                    return 0;
                    };

                pocket.setTexCoord = function(object) {
                    if (object.texCoordBuffer) {
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.texCoordBuffer);
                        this.pocketGL.gl.vertexAttribPointer(object.shaderProgram.textureCoordAttribute, object.texCoordBuffer.itemSize, this.pocketGL.gl.FLOAT, false, 0, 0);
                        this.pocketGL.gl.enableVertexAttribArray(object.shaderProgram.textureCoordAttribute);
                        if (object.shaderProgram.samplerUniform) {
                            this.pocketGL.gl.uniform1i(object.shaderProgram.samplerUniform, 0);
                        }
                        return 1;
                        }
                    return 0;
                    };

                /* Set the ambient light                         */
                pocket.setAmbientLight = function(object,red,green,blue) {
                    if (object.shaderProgram.ambientColorUniform) {
                        this.pocketGL.gl.uniform3f(object.shaderProgram.ambientColorUniform,parseFloat(red),parseFloat(green),parseFloat(blue));
                        }
                    };

                /* Set the directional light                     */
                pocket.setDirectionalLight = function(object,red,green,blue) {
                    if (object.shaderProgram.directionalColorUniform) {
                        this.pocketGL.gl.uniform3f(object.shaderProgram.directionalColorUniform,parseFloat(red),parseFloat(green),parseFloat(blue));
                        }
                    };

                /* Set the light direction                       */
                pocket.setLightDirection = function(object,dirX,dirY,dirZ) {
                    if (object.shaderProgram.lightingDirectionUniform) {
                        var lightingDirection = [parseFloat(dirX),parseFloat(dirY),parseFloat(dirZ)];

                        /* Normalize the direction               */
                        var adjustedLD = glMatrix.vec3.create();
                        glMatrix.vec3.normalize(adjustedLD,lightingDirection);
                        glMatrix.vec3.scale(adjustedLD, adjustedLD, -1);
                        this.pocketGL.gl.uniform3fv(object.shaderProgram.lightingDirectionUniform, adjustedLD);
                        }
                    };

                /* Set global background color                   */
                pocket.setGlobalBack = function(red,green,blue) {
                    this.pocketGL.gl.clearColor(red,green,blue,1.0);
                    };

                /* Draw Perspective                              */
                pocket.renderPerspective = function() {
                    this.pocketGL.gl.viewport(0, 0, this.pocketGL.gl.viewportWidth, this.pocketGL.gl.viewportHeight);
                    this.pocketGL.gl.clear(this.pocketGL.gl.COLOR_BUFFER_BIT | this.pocketGL.gl.DEPTH_BUFFER_BIT);

                    /* Field of view, Width height ratio, min distance of viewpoint, max distance of viewpoint, */
                    glMatrix.mat4.perspective(this.pMatrix, degToRad(this.pocketGL.depthField), (this.pocketGL.gl.viewportWidth / this.pocketGL.gl.viewportHeight), 0.1, 100.0);
                    };

                /* Calculate rotatory speed                      */
                /* rotationObject, deltaSeconds */
                pocket.animate = function(rotationObject, deltaSeconds) {
                    if (!deltaSeconds) deltaSeconds = 0.016; /* fallback ~60fps */
                    /* use rotationSpeed degrees per second */
                    rotationObject.rotValue += rotationObject.rotationSpeed * deltaSeconds;
                };

                /* Simple GL error checker (logs if any error occurs) */
                /* Map WebGL error enums to readable names for diagnostics */
                pocket.getGLErrorName = function(err) {
                    try {
                        var gl = this.pocketGL.gl;
                        var map = {};
                        map[gl.NO_ERROR] = 'NO_ERROR';
                        map[gl.INVALID_ENUM] = 'INVALID_ENUM';
                        map[gl.INVALID_VALUE] = 'INVALID_VALUE';
                        map[gl.INVALID_OPERATION] = 'INVALID_OPERATION';
                        // INVALID_FRAMEBUFFER_OPERATION is not in WebGL1 on all platforms but include if present
                        if (typeof gl.INVALID_FRAMEBUFFER_OPERATION !== 'undefined') map[gl.INVALID_FRAMEBUFFER_OPERATION] = 'INVALID_FRAMEBUFFER_OPERATION';
                        map[gl.OUT_OF_MEMORY] = 'OUT_OF_MEMORY';
                        return map[err] || ('UNKNOWN_ERROR(0x' + err.toString(16) + ')');
                        }
                    catch (e) {
                        return String(err);
                        }
                };

                /* Improved GL error checker: drains errors and logs human-friendly names */
                pocket.checkGLError = function(location) {
                    try {
                        var gl = this.pocketGL.gl;
                        var err = gl.getError();
                        while (err !== gl.NO_ERROR) {
                            printLog('WebGL error at ' + (location || 'unknown') + ': ' + this.getGLErrorName(err));
                            err = gl.getError();
                            }
                        } 
                    catch (e) {
                        /* ignore if gl not available */
                        }
                };

                /* Buffer Triangle                               */
                pocket.bufferTriangle = function(object) {
                    /* Vertex                                    */
                    if (object.size) {
                        printLog("        Buffer the " + object.type + "'s vertex");
                        object.vertexPositionBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexPositionBuffer);
                        var vertices = [
                             0.0,            object.size,    0.0,
                            -object.size,   -object.size,    0.0,
                             object.size,   -object.size,    0.0
                            ];
                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(vertices), this.pocketGL.gl.STATIC_DRAW);

                        object.vertexPositionBuffer.itemSize = 3;
                        object.vertexPositionBuffer.numItems = 3;
                        }

                    /* Color                                     */
                    if (object.color) {
                        printLog("        Buffer the " + object.type + "'s color");
                        object.vertexColorBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexColorBuffer);
                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(object.color), this.pocketGL.gl.STATIC_DRAW);

                        object.vertexColorBuffer.itemSize = 4;
                        object.vertexColorBuffer.numItems = 3;
                        }
                    };

                /* Buffer Square                                 */
                pocket.bufferSquare = function(object) {
                    /* Vertex                                    */
                    if (object.size) {
                        printLog("        Buffer the " + object.type + "'s vertex");
                        object.vertexPositionBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexPositionBuffer);
                        var vertices = [
                             object.size,  object.size,  0.0,
                            -object.size,  object.size,  0.0,
                             object.size, -object.size,  0.0,
                            -object.size, -object.size,  0.0
                            ];
                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(vertices), this.pocketGL.gl.STATIC_DRAW);

                        object.vertexPositionBuffer.itemSize = 3;
                        object.vertexPositionBuffer.numItems = 4;
                        }

                    /* Color                                     */
                    if (object.color) {
                        printLog("        Buffer the " + object.type + "'s color");
                        object.vertexColorBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexColorBuffer);
                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(object.color), this.pocketGL.gl.STATIC_DRAW);

                        object.vertexColorBuffer.itemSize = 4;
                        object.vertexColorBuffer.numItems = 4;
                        }

                    /* Texture                                   */
                    if (object.texture && (null !== object.shaderProgram.textureCoordAttribute)) {
                        printLog("        Buffer the " + object.type + "'s texture. GL Texture Location:" + pocket.texCount);
                        object.texCoordBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.texCoordBuffer);
                        var textureCoords = [
                            // Front face
                            0.0, 1.0,
                            1.0, 1.0,
                            0.0, 0.0,
                            1.0, 0.0
                            ];
                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(textureCoords), this.pocketGL.gl.STATIC_DRAW);
                        object.texCoordBuffer.itemSize = 2;
                        object.texCoordBuffer.numItems = 4;

                        object.texCount = pocket.texCount;
                        pocket.texCount = pocket.texCount + 1;
                        }

                    /* Normals                                   */
                    if (object.shaderProgram.useLightingUniform) {
                        printLog("        Buffer the " + object.type + "'s normals");
                        object.vertexNormalBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexNormalBuffer);
                        var vertexNormals = [
                            // One normal per vertex (square has 4 verts)
                             0.0,  0.0,  1.0,
                             0.0,  0.0,  1.0,
                             0.0,  0.0,  1.0,
                             0.0,  0.0,  1.0
                            ];
                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(vertexNormals), this.pocketGL.gl.STATIC_DRAW);
                        object.vertexNormalBuffer.itemSize = 3;
                        object.vertexNormalBuffer.numItems = 4;
                    }

                    /* Indices                                   */
                    printLog("        Buffer the " + object.type + "'s indices");
                    object.vertexIndexBuffer = this.pocketGL.gl.createBuffer();
                    this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ELEMENT_ARRAY_BUFFER, object.vertexIndexBuffer);
                    var squareVertexIndices = [
                      0, 1, 2,      0, 2, 3    // Front face
                      ];

                    this.pocketGL.gl.bufferData(this.pocketGL.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(squareVertexIndices), this.pocketGL.gl.STATIC_DRAW);
                    object.vertexIndexBuffer.itemSize = 1;
                    object.vertexIndexBuffer.numItems = 6;
                    };

                /* Buffer Cube                                   */
                pocket.bufferCube = function(object) {
                    /* Vertex                                    */
                    if (object.size) {
                        printLog("        Buffer the " + object.type + "'s vertex");
                        object.vertexPositionBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexPositionBuffer);
                        var vertices = [
                            // Front face
                            -object.size, -object.size,  object.size,
                             object.size, -object.size,  object.size,
                             object.size,  object.size,  object.size,
                            -object.size,  object.size,  object.size,

                            // Back face
                            -object.size, -object.size, -object.size,
                            -object.size,  object.size, -object.size,
                             object.size,  object.size, -object.size,
                             object.size, -object.size, -object.size,

                            // Top face
                            -object.size,  object.size, -object.size,
                            -object.size,  object.size,  object.size,
                             object.size,  object.size,  object.size,
                             object.size,  object.size, -object.size,

                            // Bottom face
                            -object.size, -object.size, -object.size,
                             object.size, -object.size, -object.size,
                             object.size, -object.size,  object.size,
                            -object.size, -object.size,  object.size,

                            // Right face
                             object.size, -object.size, -object.size,
                             object.size,  object.size, -object.size,
                             object.size,  object.size,  object.size,
                             object.size, -object.size,  object.size,

                            // Left face
                            -object.size, -object.size, -object.size,
                            -object.size, -object.size,  object.size,
                            -object.size,  object.size,  object.size,
                            -object.size,  object.size, -object.size
                            ];
                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(vertices), this.pocketGL.gl.STATIC_DRAW);

                        object.vertexPositionBuffer.itemSize = 3;
                        object.vertexPositionBuffer.numItems = 24;
                        }

                    /* Color                                     */
                    if (object.color && (null !== object.shaderProgram.vertexColorAttribute)) {
                        printLog("        Buffer the " + object.type + "'s color");
                        object.vertexColorBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexColorBuffer);

                        var unpackedColors = [];
                        for (var i = 0; i < object.color.length; i++) {
                            var color = object.color[i];
                            for (var r = 0; r < 4; r++) {
                                unpackedColors = unpackedColors.concat(color);
                            }
                        }

                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(unpackedColors), this.pocketGL.gl.STATIC_DRAW);
                        object.vertexColorBuffer.itemSize = 4;
                        object.vertexColorBuffer.numItems = 24;
                        }

                    /* Texture                                   */
                    if (object.texture && (null !== object.shaderProgram.textureCoordAttribute)) {
                        printLog("        Buffer the " + object.type + "'s texture. GL Texture Location:" + pocket.texCount);
                        object.texCoordBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.texCoordBuffer);
                        var textureCoords = [
                            // Front face
                            0.0, 0.0,
                            1.0, 0.0,
                            1.0, 1.0,
                            0.0, 1.0,

                            // Back face
                            1.0, 0.0,
                            1.0, 1.0,
                            0.0, 1.0,
                            0.0, 0.0,

                            // Top face
                            0.0, 1.0,
                            0.0, 0.0,
                            1.0, 0.0,
                            1.0, 1.0,

                            // Bottom face
                            1.0, 1.0,
                            0.0, 1.0,
                            0.0, 0.0,
                            1.0, 0.0,

                            // Right face
                            1.0, 0.0,
                            1.0, 1.0,
                            0.0, 1.0,
                            0.0, 0.0,

                            // Left face
                            0.0, 0.0,
                            1.0, 0.0,
                            1.0, 1.0,
                            0.0, 1.0,
                            ];
                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(textureCoords), this.pocketGL.gl.STATIC_DRAW);
                        object.texCoordBuffer.itemSize = 2;
                        object.texCoordBuffer.numItems = 24;

                        object.texCount = pocket.texCount;
                        pocket.texCount = pocket.texCount + 1;
                        }

                    /* Normals                                   */
                    if (object.shaderProgram.useLightingUniform) {
                        printLog("        Buffer the " + object.type + "'s normals");
                        object.vertexNormalBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexNormalBuffer);
                        var vertexNormals = [
                            // Front face
                             0.0,  0.0,  1.0,
                             0.0,  0.0,  1.0,
                             0.0,  0.0,  1.0,
                             0.0,  0.0,  1.0,

                            // Back face
                             0.0,  0.0, -1.0,
                             0.0,  0.0, -1.0,
                             0.0,  0.0, -1.0,
                             0.0,  0.0, -1.0,

                            // Top face
                             0.0,  1.0,  0.0,
                             0.0,  1.0,  0.0,
                             0.0,  1.0,  0.0,
                             0.0,  1.0,  0.0,

                            // Bottom face
                             0.0, -1.0,  0.0,
                             0.0, -1.0,  0.0,
                             0.0, -1.0,  0.0,
                             0.0, -1.0,  0.0,

                            // Right face
                             1.0,  0.0,  0.0,
                             1.0,  0.0,  0.0,
                             1.0,  0.0,  0.0,
                             1.0,  0.0,  0.0,

                            // Left face
                            -1.0,  0.0,  0.0,
                            -1.0,  0.0,  0.0,
                            -1.0,  0.0,  0.0,
                            -1.0,  0.0,  0.0
                            ];
                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(vertexNormals), this.pocketGL.gl.STATIC_DRAW);
                        object.vertexNormalBuffer.itemSize = 3;
                        object.vertexNormalBuffer.numItems = 24;
                        }

                    /* Indices                                   */
                    printLog("        Buffer the " + object.type + "'s indices");
                    object.vertexIndexBuffer = this.pocketGL.gl.createBuffer();
                    this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ELEMENT_ARRAY_BUFFER, object.vertexIndexBuffer);
                    var cubeVertexIndices = [
                      0, 1, 2,      0, 2, 3,    // Front face
                      4, 5, 6,      4, 6, 7,    // Back face
                      8, 9, 10,     8, 10, 11,  // Top face
                      12, 13, 14,   12, 14, 15, // Bottom face
                      16, 17, 18,   16, 18, 19, // Right face
                      20, 21, 22,   20, 22, 23  // Left face
                      ];

                    this.pocketGL.gl.bufferData(this.pocketGL.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), this.pocketGL.gl.STATIC_DRAW);
                    object.vertexIndexBuffer.itemSize = 1;
                    object.vertexIndexBuffer.numItems = 36;
                    };

                /* Buffer Pyramid                                */
                pocket.bufferPyramid = function(object) {
                    /* Vertex                                    */
                    if (object.size) {
                        printLog("        Buffer the " + object.type + "'s vertex");
                        object.vertexPositionBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexPositionBuffer);
                        var vertices = [
                            // Front face
                             0.0,          object.size,  0.0,
                            -object.size, -object.size,  object.size,
                             object.size, -object.size,  object.size,

                            // Right face
                             0.0,          object.size,  0.0,
                             object.size, -object.size,  object.size,
                             object.size, -object.size, -object.size,

                            // Back face
                             0.0,          object.size,  0.0,
                             object.size, -object.size, -object.size,
                            -object.size, -object.size, -object.size,

                            // Left face
                             0.0,          object.size,  0.0,
                            -object.size, -object.size, -object.size,
                            -object.size, -object.size,  object.size,

                            //Bottom left
                            -object.size, -object.size,  object.size,
                             object.size, -object.size,  object.size,
                             object.size, -object.size, -object.size,

                            //Bottom right
                            -object.size, -object.size,  object.size,
                             object.size, -object.size, -object.size,
                            -object.size, -object.size, -object.size
                            ];
                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(vertices), this.pocketGL.gl.STATIC_DRAW);

                        object.vertexPositionBuffer.itemSize = 3;
                        object.vertexPositionBuffer.numItems = 18;
                        }

                    /* Color                                     */
                    if (object.color) {
                        printLog("        Buffer the " + object.type + "'s color");
                        object.vertexColorBuffer = this.pocketGL.gl.createBuffer();
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ARRAY_BUFFER, object.vertexColorBuffer);

                        this.pocketGL.gl.bufferData(this.pocketGL.gl.ARRAY_BUFFER, new Float32Array(object.color), this.pocketGL.gl.STATIC_DRAW);

                        object.vertexColorBuffer.itemSize = 4;
                        object.vertexColorBuffer.numItems = 18;
                        }
                    };

                /* Draw Object                                   */
                pocket.drawObject = function(object,renderType,mode) {
                    var lighting = 0;
                    looper = 0;
                    if (document.getElementById("lighting")) {
                        lighting = document.getElementById("lighting").checked;
                        }

                    glMatrix.mat4.identity(object.mvMatrix);
                    this.mvPushMatrix(object.mvMatrix,this.mvMatrixStack);
                    
                    this.camera.setCamera(object.mvMatrix,keyboardPress);

                    /* Push the object to the preferred location (apply to model-view matrix) */
                    glMatrix.mat4.translate(object.mvMatrix, object.mvMatrix, object.location);
                    glMatrix.mat4.rotate(object.mvMatrix, object.mvMatrix, degToRad(object.rotValue), object.rotDirection);

                    /* Set the vertex and color                  */
                    looper = looper + this.setVertexPosition(object) + this.setVertexColor(object);

                    if (object.shaderProgram.useLightingUniform) {
                        this.pocketGL.gl.uniform1i(object.shaderProgram.useLightingUniform, lighting);

                        /* Set the normals                       */
                        looper = looper + this.setVertexNormal(object);

                        if (lighting) {
                            /* Set the ambient light             */
                            if (document.getElementById('ambLight') && document.getElementById('ambLight').color) {
                                this.setAmbientLight(object,
                                  document.getElementById('ambLight').color.rgb[0],
                                  document.getElementById('ambLight').color.rgb[1],
                                  document.getElementById('ambLight').color.rgb[2]);
                                }
                            else {
                                this.setAmbientLight(object,0.2,0,0);
                                }

                            /* Set the directional light         */
                            if (document.getElementById('dirLight') && document.getElementById('dirLight').color) {
                                this.setDirectionalLight(object,
                                  document.getElementById('dirLight').color.rgb[0],
                                  document.getElementById('dirLight').color.rgb[1],
                                  document.getElementById('dirLight').color.rgb[2]);
                                }
                            else {
                                this.setDirectionalLight(object,0.2,0,0);
                                }

                            /* Set the light direction           */
                            if (document.getElementById("dirX") && document.getElementById("dirY") && document.getElementById("dirZ")) {
                                this.setLightDirection(object,
                                  document.getElementById("dirX").value,
                                  document.getElementById("dirY").value,
                                  document.getElementById("dirZ").value);
                                }
                            else {
                                this.setLightDirection(object,-1,-1,-1);
                                }
                            }
                        else {
                            /* Set them just in case             */
                            if (object.shaderProgram.ambientColorUniform) {
                                this.pocketGL.gl.uniform3f(object.shaderProgram.ambientColorUniform,parseFloat(0),parseFloat(0),parseFloat(0));
                                }
                            if (object.shaderProgram.directionalColorUniform) {
                                this.pocketGL.gl.uniform3f(object.shaderProgram.directionalColorUniform,parseFloat(0),parseFloat(0),parseFloat(0));
                                }
                            }
                        }

                    /* Set the texture                           */
                    looper = looper + this.setTexCoord(object);

                    /* Bind the indices if present               */
                    if (object.vertexIndexBuffer) {
                        this.pocketGL.gl.bindBuffer(this.pocketGL.gl.ELEMENT_ARRAY_BUFFER, object.vertexIndexBuffer);
                        }

                    /* Set uniforms                              */
                    this.setMatrixUniforms(object,this.pMatrix,object.mvMatrix);

                    /* Disable Unused attributes                 */
                    this.disableUnusedAttr(this.pocketGL.gl, looper);

                    /* Draw based on type                        */
                    /* POINTS,
                       LINE_STRIP, LINES,
                       TRIANGLES, TRIANGLE_STRIP                 */
                    if ("DRAWARRAYS" == renderType) {
                        if ("TRIANGLES" == mode) {
                            this.pocketGL.gl.drawArrays(this.pocketGL.gl.TRIANGLES, 0, object.vertexPositionBuffer.numItems);
                            }
                        if ("TRIANGLE_STRIP" == mode) {
                            this.pocketGL.gl.drawArrays(this.pocketGL.gl.TRIANGLE_STRIP, 0, object.vertexPositionBuffer.numItems);
                            }
                        }
                    if ("DRAWELEMENTS" == renderType) {
                        if ("TRIANGLES" == mode) {
                             this.pocketGL.gl.drawElements(this.pocketGL.gl.TRIANGLES, object.vertexIndexBuffer.numItems, this.pocketGL.gl.UNSIGNED_SHORT, 0);
                            }
                        if ("TRIANGLE_STRIP" == mode) {
                             this.pocketGL.gl.drawElements(this.pocketGL.gl.TRIANGLE_STRIP, object.vertexIndexBuffer.numItems, this.pocketGL.gl.UNSIGNED_SHORT, 0);
                            }
                        }
                    this.mvPopMatrix(object.mvMatrix,this.mvMatrixStack);
                    };

                /* Repeated draw functionality. No threading.    */
                function reDraw() {
                    drawLooper = 0;
                    /* Initiate redraw                           */
                    reDrawID = requestAnimFrame(reDraw);

                    /* compute deltaSeconds for this frame */
                    var now = (new Date()).getTime();
                    if (!pocket._lastAnim) pocket._lastAnim = now;
                    var deltaSeconds = (now - pocket._lastAnim) / 1000.0;
                    pocket._lastAnim = now;

                    /* Set global background                     */
                    if (document.getElementById('perspBack') && document.getElementById('perspBack').color) {
                        pocket.setGlobalBack(document.getElementById('perspBack').color.rgb[0],
                          document.getElementById('perspBack').color.rgb[1],
                          document.getElementById('perspBack').color.rgb[2]);
                        }
                    else {
                        pocket.setGlobalBack(0,0,0);
                        }

                    /* Render the Perspective                    */
                    pocket.renderPerspective();

                    /* Draw the contents                         */
                    while (drawLooper <= pocket.contentList.length-1) {
                        if ("triangle" == pocket.contentList[drawLooper].type
                          || "pyramid" == pocket.contentList[drawLooper].type) {
                            pocket.pocketGL.gl.useProgram(pocket.contentList[drawLooper].shaderProgram);
                            pocket.drawObject(pocket.contentList[drawLooper],"DRAWARRAYS","TRIANGLES");
                            pocket.animate(pocket.contentList[drawLooper], deltaSeconds);
                            pocket.checkGLError(pocket.contentList[drawLooper].type);
                            }
                        if ("square" == pocket.contentList[drawLooper].type
                          || "squareTex" == pocket.contentList[drawLooper].type) {
                            pocket.pocketGL.gl.useProgram(pocket.contentList[drawLooper].shaderProgram);
                            pocket.drawObject(pocket.contentList[drawLooper],"DRAWARRAYS","TRIANGLE_STRIP");
                            pocket.animate(pocket.contentList[drawLooper], deltaSeconds);
                            pocket.checkGLError(pocket.contentList[drawLooper].type);
                            }
                        if ("cube"          == pocket.contentList[drawLooper].type
                          || "cubeTex"      == pocket.contentList[drawLooper].type
                          || "cubeLightTex" == pocket.contentList[drawLooper].type) {
                            pocket.pocketGL.gl.useProgram(pocket.contentList[drawLooper].shaderProgram);
                            pocket.drawObject(pocket.contentList[drawLooper],"DRAWELEMENTS","TRIANGLES");
                            pocket.animate(pocket.contentList[drawLooper], deltaSeconds);
                            pocket.checkGLError(pocket.contentList[drawLooper].type);
                            }
                        drawLooper = drawLooper + 1;
                        }

                    /* Update the frame rate                     */
                    framesPerSecObject.updateFPS();

                    /* Set the FPS data                          */
                    if (document.getElementById('fps')) {
                        document.getElementById('fps').innerHTML = "FPS AVG: " + Math.floor(framesPerSecObject.getAvgFPS())
                          + " CUR: " + Math.floor(framesPerSecObject.getCurFPS());
                        }

                    /* Kill after final iteration                */
                    if (document.getElementById("stopIteration") && document.getElementById("stopIteration").value > 1) {
                        if (reDrawID > document.getElementById("stopIteration").value) {
                            pocket.destroy(reDrawID);
                            document.getElementById("stopIteration").value = document.getElementById("stopIteration").value * 2;
                            }
                        }
                    }

                /* Fill pocket based on content                  */
                pocket.fillPocket = function(filler,size,location) {
                    /*
                    Common conventions to be followed across
                    Contents can contain any type of objects. Each object can be a triangle, cube etc.
                    object.type                 =    Contains the type of object namely triangle, cube
                    object.size                 =    Contains the size of the object. 1 unit will be the same as how WEBGL assumes 1 as in an array
                    object.sides                =    Contains the number of sides. (To be built and used)
                    object.shaderProgram        =    Contains the fragment and vertex shader
                    object.location             =    Calculate based on base location. Update based on current location.
                    object.rotationSpeed        =    Rotatory speed
                    object.rotValue             =    Dynamic rotation based on rotation
                    object.rotDirection         =    [x,y,z]
                    object.color                =    Will contain colors based on the sides clockwise. One vertice -> [R,G,B,alpha]
                    object.texture              =    If texture is present then this will be used.

                    object.texCount             =    allocated during buffering (Keep track number of the texture from pocket)
                    object.vertexPositionBuffer =    allocated during buffering
                    object.vertexColorBuffer    =    allocated during buffering
                    object.texCoordBuffer       =    allocated during buffering
                    object.vertexNormalBuffer   =    allocated during buffering
                    object.vertexIndexBuffer    =    allocated during buffering
                    */
                    printLog(" ");
                    printLog("    Fill Pocket with:" + filler + " of size:" + size);
                    if ("triangle" == filler) {
                        var triangleObject           = new Object();
                        triangleObject.type          = filler;
                        triangleObject.size          = size;
                        triangleObject.sides         = 3;
                        triangleObject.shaderProgram = this.initShaders(this.pocketGL.gl, filler+"-shader-fs", filler+"-shader-vs");
                        triangleObject.location      = location;
                        triangleObject.rotationSpeed = 90;
                        triangleObject.rotValue      = 0;
                        triangleObject.rotDirection  = [0,1,0];
                        triangleObject.color         = [
                                                        1.0, 0.0, 0.0, 1.0, // Top
                                                        0.0, 1.0, 0.0, 1.0, // Right
                                                        0.0, 0.0, 1.0, 1.0  // Bottom
                                                        ];
                        triangleObject.mvMatrix      = glMatrix.mat4.create();

                        if (triangleObject.shaderProgram) {
                            printLog("      Buffer the " + filler +  ":Store at:" + this.contentList.length);
                            this.bufferTriangle(triangleObject);
                            this.contentList[this.contentList.length] = triangleObject;
                            }
                        else {
                            printLog("      Triangle shader failure");
                            }
                        }

                    if ("square" == filler) {
                        var squareObject           = new Object();
                        squareObject.type          = filler;
                        squareObject.size          = size;
                        squareObject.sides         = 4;
                        squareObject.shaderProgram = this.initShaders(this.pocketGL.gl, filler+"-shader-fs", filler+"-shader-vs");
                        squareObject.location      = location;
                        squareObject.rotationSpeed = 75;
                        squareObject.rotValue      = 0;
                        squareObject.rotDirection  = [0,1,0];
                        squareObject.color         = [
                                                      1.0, 0.0, 0.0, 1.0, //Top right
                                                      0.0, 1.0, 0.0, 1.0, //Top left
                                                      0.0, 0.0, 1.0, 1.0, //Bottom right
                                                      0.5, 1.0, 0.5, 1.0  //Bottom left
                                                      ];
                        squareObject.mvMatrix      = glMatrix.mat4.create();

                        if (squareObject.shaderProgram) {
                            printLog("      Buffer the " + filler + ":Store at:" + this.contentList.length);
                            this.bufferSquare(squareObject);
                            this.contentList[this.contentList.length] = squareObject;
                            }
                        else {
                            printLog("      Square shader failure");
                            }
                        }

                    if ("squareTex" == filler || "squareLightTex" == filler) {
                        var squareObject           = new Object();
                        squareObject.type          = filler;
                        squareObject.size          = size;
                        squareObject.sides         = 4;
                        squareObject.shaderProgram = this.initShaders(this.pocketGL.gl, filler+"-shader-fs", filler+"-shader-vs");
                        squareObject.location      = location;
                        squareObject.rotationSpeed = 75;
                        squareObject.rotValue      = 0;
                        squareObject.rotDirection  = [0,1,0];
                        squareObject.texture       = this.initTexture(this.pocketGL.gl, "images/new.jpg");
                        squareObject.mvMatrix      = glMatrix.mat4.create();

                        if (squareObject.shaderProgram) {
                            printLog("      Buffer the " + filler + ":Store at:" + this.contentList.length);
                            this.bufferSquare(squareObject);
                            this.contentList[this.contentList.length] = squareObject;
                            }
                        else {
                            printLog("      Square shader failure");
                            }
                        }

                    if ("cube" == filler) {
                        var cubeObject           = new Object();
                        cubeObject.type          = filler;
                        cubeObject.size          = size;
                        cubeObject.sides         = 12;
                        cubeObject.shaderProgram = this.initShaders(this.pocketGL.gl, filler+"-shader-fs", filler+"-shader-vs");
                        cubeObject.location      = location;
                        cubeObject.rotationSpeed = 75;
                        cubeObject.rotValue      = 0;
                        cubeObject.rotDirection  = [1,1,1];
                        cubeObject.color         = [
                                                    [1.0, 0.0, 0.0, 1.0], // Front face
                                                    [1.0, 1.0, 0.0, 1.0], // Back face
                                                    [0.0, 1.0, 0.0, 1.0], // Top face
                                                    [1.0, 0.5, 0.5, 1.0], // Bottom face
                                                    [1.0, 0.0, 1.0, 1.0], // Right face
                                                    [0.0, 0.0, 1.0, 1.0]  // Left face
                                                    ];
                        cubeObject.mvMatrix      = glMatrix.mat4.create();

                        if (cubeObject.shaderProgram) {
                            printLog("      Buffer the " + filler + ":Store at:" + this.contentList.length);
                            this.bufferCube(cubeObject);
                            this.contentList[this.contentList.length] = cubeObject;
                            }
                        else {
                            printLog("      Cube shader failure");
                            }
                        }

                    if ("cubeTex" == filler || "cubeLightTex" == filler) {
                        var cubeObject           = new Object();
                        cubeObject.type          = filler;
                        cubeObject.size          = size;
                        cubeObject.sides         = 12;
                        cubeObject.shaderProgram = this.initShaders(this.pocketGL.gl, filler+"-shader-fs", filler+"-shader-vs");
                        cubeObject.location      = location;
                        cubeObject.rotationSpeed = 20;
                        cubeObject.rotValue      = 0;
                        cubeObject.rotDirection  = [1,1,1];
                        cubeObject.texture       = this.initTexture(this.pocketGL.gl, "images/new.jpg");
                        cubeObject.mvMatrix      = glMatrix.mat4.create();

                        if (cubeObject.shaderProgram) {
                            printLog("      Buffer the " + filler + ":Store at:" + this.contentList.length);
                            this.bufferCube(cubeObject);
                            this.contentList[this.contentList.length] = cubeObject;
                            }
                        else {
                            printLog("      Cube shader failure");
                            }
                        }

                    if ("pyramid" == filler) {
                        var pyramidObject           = new Object();
                        pyramidObject.type          = filler;
                        pyramidObject.size          = size;
                        pyramidObject.sides         = 8;
                        pyramidObject.shaderProgram = this.initShaders(this.pocketGL.gl, filler+"-shader-fs", filler+"-shader-vs");
                        pyramidObject.location      = location;
                        pyramidObject.rotationSpeed = 90;
                        pyramidObject.rotValue      = 0;
                        pyramidObject.rotDirection  = [0,1,0];
                        pyramidObject.color         = [
                                                        // Front face
                                                        1.0, 0.0, 0.0, 1.0,
                                                        0.0, 1.0, 0.0, 1.0,
                                                        0.0, 0.0, 1.0, 1.0,

                                                        // Right face
                                                        1.0, 0.0, 0.0, 1.0,
                                                        0.0, 0.0, 1.0, 1.0,
                                                        0.0, 1.0, 0.0, 1.0,

                                                        // Back face
                                                        1.0, 0.0, 0.0, 1.0,
                                                        0.0, 1.0, 0.0, 1.0,
                                                        0.0, 0.0, 1.0, 1.0,

                                                        // Left face
                                                        1.0, 0.0, 0.0, 1.0,
                                                        0.0, 0.0, 1.0, 1.0,
                                                        0.0, 1.0, 0.0, 1.0,

                                                        // Bottom left
                                                        0.0, 1.0, 0.0, 1.0,
                                                        0.0, 0.0, 1.0, 1.0,
                                                        0.0, 1.0, 0.0, 1.0,

                                                        // Bottom right
                                                        0.0, 1.0, 0.0, 1.0,
                                                        0.0, 1.0, 0.0, 1.0,
                                                        0.0, 0.0, 1.0, 1.0
                                                        ];
                        pyramidObject.mvMatrix      = glMatrix.mat4.create();

                        if (pyramidObject.shaderProgram) {
                            printLog("      Buffer the " + filler + ":Store at:" + this.contentList.length);
                            this.bufferPyramid(pyramidObject);
                            this.contentList[this.contentList.length] = pyramidObject;
                            }
                        else {
                            printLog("      Pyramid shader failure");
                            }
                        }
                    };

                pocket.callReDraw = function() {
                    printLog("    Calling Redraw");
                    requestAnimFrame(reDraw);
                    };

                /* Destructor                                    */
                pocket.destroy = function() {
                    printLog("    Destroy render at iteration:" + reDrawID);
                    /* Stop the render                           */
                    try { cancelRequestAnimFrame(reDrawID); } catch (e) {}

                    var gl = this.pocketGL && this.pocketGL.gl;

                    // Iterate and free GL resources for each content entry
                    try {
                        for (var i = 0; this.contentList && i < this.contentList.length; i++) {
                            var item = this.contentList[i];
                            if (!item) continue;
                            printLog("    Destroying: " + (item.type || 'unknown'));

                            // Delete buffers
                            try {
                                if (gl) {
                                    if (item.vertexPositionBuffer) { gl.deleteBuffer(item.vertexPositionBuffer); }
                                    if (item.texCoordBuffer) { gl.deleteBuffer(item.texCoordBuffer); }
                                    if (item.vertexColorBuffer) { gl.deleteBuffer(item.vertexColorBuffer); }
                                    if (item.vertexNormalBuffer) { gl.deleteBuffer(item.vertexNormalBuffer); }
                                    if (item.vertexIndexBuffer) { gl.deleteBuffer(item.vertexIndexBuffer); }
                                    if (item.texture) { gl.deleteTexture(item.texture); }
                                    if (item.shaderProgram) {
                                        try {
                                            if (item.shaderProgram.fragmentShader) gl.deleteShader(item.shaderProgram.fragmentShader);
                                            if (item.shaderProgram.vertexShader) gl.deleteShader(item.shaderProgram.vertexShader);
                                            gl.deleteProgram(item.shaderProgram);
                                        } catch (e) {}
                                    }
                                }
                            } catch (e) { /* ignore GL delete errors */ }

                            // Null out references so GC can collect
                            item.vertexPositionBuffer = null;
                            item.texCoordBuffer       = null;
                            item.vertexColorBuffer    = null;
                            item.vertexNormalBuffer   = null;
                            item.vertexIndexBuffer    = null;
                            item.texture              = null;
                            item.shaderProgram        = null;
                            item.mvMatrix             = null;
                            item.color                = null;
                            item.location             = null;
                        }
                    } catch (e) { /* ignore iteration errors */ }

                    // Clear the content list
                    try { if (this.contentList) this.contentList.length = 0; } catch (e) {}

                    // Destroy camera and base pocket safely
                    try { if (this.camera && typeof this.camera.destroy === 'function') this.camera.destroy(); } catch (e) {}
                    try { if (this.pocketGL && typeof this.pocketGL.destroy === 'function') this.pocketGL.destroy(); } catch (e) {}

                    // Null out remaining references
                    this.pMatrix = null;
                    this.mvMatrixStack = null;
                    this.texCount = null;
                    this.contentList = null;
                    this.camera = null;
                    this.pocketGL = null;
                    };

                return pocket;
                }

            /* WebGL end                                         */
            /*****************************************************/

            function drawFPS(screenWidth,screenHeight) {
                printLog("  Draw the FPS section");
                printf('<div style="height:40;width:'+screenWidth+';">');
                printf('<button id="stopRender" type="button" >Stop Render</button>');
                printf('<font color = "white">');
                printf('Stop At Iteration:<input id="stopIteration" type="text" value="0" size="4" disabled/>');
                printf('<b id="fps"></b>');
                printf('</font>');
                printf('</div>');
                }

            /* Draw Developer section                            */
            function drawDevToolBar(screenWidth,screenHeight) {
                printLog("  Draw the Developer Toolbar");
                printf('<font color = "white">');
                printf('<table border=1 style="height:'+screenHeight/8+';width:'+screenWidth+';">');

                /* Title                                         */
                printf('<tr>');
                printf('<td>Perspective Color</td>');
                printf('<td>Directional Light<input id="lighting" type="checkbox" checked /></td>');
                printf('<td>Ambient Light</td>');
                printf('<td>Direction of Light Source</td>');
                printf('<td>Depth or Blend</td>');
                printf('</tr>');

                /* Functionality                                 */
                printf('<tr>');
                printf('<td><input id = "perspBack" class="color" value="00FF00"></td>');
                printf('<td><input id = "dirLight" class="color" value="FFFFFF"></td>');
                printf('<td><input id = "ambLight" class="color" value="0000FF"></td>');
                printf('<td>X: <input id="dirX" type="text" value="-1.0" size="4" />Y: <input id="dirY" type="text" value="-1.0" size="4" />Z: <input id="dirZ" type="text" value="-1.0" size="4" /></td>');
                printf('<td>');
                printf('<select id = "depthBlend"><option value="none">None</option><option value="depth">Depth</option><option value="blend">Blend</option></select>');
                printf('<select id = "depthParam">');
                printf('<option value="NEVER">NEVER</option><option value="ALWAYS">ALWAYS</option>');
                printf('<option value="LESS">LESS</option><option value="GREATER">GREATER</option>');
                printf('<option value="EQUAL">EQUAL</option><option value="NOTEQUAL">NOTEQUAL</option>');
                printf('<option value="LEQUAL">LEQUAL</option><option value="GEQUAL">GEQUAL</option>');
                printf('</select>');
                printf('<select id = "blendSrcParam">');
                printf('<option value="ZERO">ZERO</option><option value="ONE">ONE</option>');
                printf('<option value="SRC_COLOR">SRC_COLOR</option><option value="ONE_MINUS_SRC_COLOR">ONE_MINUS_SRC_COLOR</option>');
                printf('<option value="SRC_ALPHA">SRC_ALPHA</option><option value="ONE_MINUS_SRC_ALPHA">ONE_MINUS_SRC_ALPHA</option>');
                printf('<option value="SRC_ALPHA_SATURATE">SRC_ALPHA_SATURATE</option>');
                printf('</select>');
                printf('<select id = "blendDestParam">');
                printf('<option value="ZERO">ZERO</option><option value="ONE">ONE</option>');
                printf('<option value="DST_COLOR">DST_COLOR</option><option value="ONE_MINUS_DST_COLOR">ONE_MINUS_DST_COLOR</option>');
                printf('<option value="DST_ALPHA">DST_ALPHA</option><option value="ONE_MINUS_DST_ALPHA">ONE_MINUS_DST_ALPHA</option>');
                printf('</select>');
                printf('</td>');
                printf('</tr>');

                printf('</table>');
                printf('</font>');
                }

            function setDepthBlendTools(depthBlend) {
                if (depthBlend == "depth") {
                    document.getElementById('depthParam').style.display     = '';
                    document.getElementById('blendSrcParam').style.display  = 'none';
                    document.getElementById('blendDestParam').style.display = 'none';
                    }
                if (depthBlend == "blend") {
                    document.getElementById('depthParam').style.display     = 'none';
                    document.getElementById('blendSrcParam').style.display  = '';
                    document.getElementById('blendDestParam').style.display = '';
                    }
                if (depthBlend == "none") {
                    document.getElementById('depthParam').style.display     = 'none';
                    document.getElementById('blendSrcParam').style.display  = 'none';
                    document.getElementById('blendDestParam').style.display = 'none';
                    }
                }

            /* Draw the canvas                                   */
            function drawCanvas (screenWidth,screenHeight) {
                /* Accommodate the developer tool-bar first      */
                printLog("  Draw the canvas");
                printf('<div style="height:'+(screenHeight - screenHeight/8)+';width:'+screenWidth+';float:left;border:1px solid;border-color:#999999">');
                printf('<canvas id="canvas" style="border: none;" width="'+screenWidth+'" height="'+(screenHeight - screenHeight/8)+'"></canvas>');
                printf('</div>');
                }

            function webGLStart() {
                printLog("  Start the WEBGL");
                var canvas  = document.getElementById("canvas");

                /* Create a Pocket based on WebGL                */
                var pocket  = definePocket(canvas);

                if (0 == pocket) {
                    /* Canvas has not been initialized           */
                    printLog("  Canvas could not be initialized");
                    }
                else {
                    /* Consider I do not want the button         */
                    if (document.getElementById('stopRender')) {
                        document.getElementById('stopRender').onclick = function() {onExit(objListToDispose)};
                        }

                    pocket.callReDraw();

                    /* Note: You start from 0,0,0                */
                    pocket.fillPocket("triangle"       ,1, [+9.5, 0.0, 0.0]);
                    pocket.fillPocket("square"         ,1, [-3.0, 0.0, 0.0]);
                    pocket.fillPocket("cubeTex"        ,1, [-3.5, 0.0, 0.0]);
                    pocket.fillPocket("cube"           ,1, [-3.5, 0.0, 0.0]);
                    pocket.fillPocket("pyramid"        ,1, [-3.5, 0.0, 0.0]);
                    pocket.fillPocket("cubeLightTex"   ,1, [-4.5, 0.0, 0.0]);
                    pocket.fillPocket("squareTex"      ,1, [-4.0, 0.0, 0.0]);
                    pocket.fillPocket("squareLightTex" ,1, [-6.0, 0.0, 0.0]);

                    /* Dev toolbar depth/blend settings          */
                    if (document.getElementById('depthBlend')) {
                        /* initialize depth/blend UI immediately if DOM is ready, otherwise on load */
                        if (document.readyState === 'complete' || document.readyState === 'interactive') {
                            setDepthBlendTools(document.getElementById('depthBlend').value);
                        } else {
                            window.addEventListener('load', function() {
                                setDepthBlendTools(document.getElementById('depthBlend').value);
                            });
                        }
                        document.getElementById('depthBlend').onchange = function() {
                            setDepthBlendTools(document.getElementById('depthBlend').value);
                            pocket.setDepthBlend(document.getElementById('depthBlend').value,
                              document.getElementById('depthParam').value,
                              document.getElementById('blendSrcParam').value,
                              document.getElementById('blendDestParam').value);
                            };
                        document.getElementById('depthParam').onchange = function() {
                            pocket.setDepthBlend(document.getElementById('depthBlend').value,
                              document.getElementById('depthParam').value,
                              document.getElementById('blendSrcParam').value,
                              document.getElementById('blendDestParam').value);
                            };
                        document.getElementById('blendSrcParam').onchange = function() {
                            pocket.setDepthBlend(document.getElementById('depthBlend').value,
                              document.getElementById('depthParam').value,
                              document.getElementById('blendSrcParam').value,
                              document.getElementById('blendDestParam').value);
                            };
                        document.getElementById('blendDestParam').onchange = function() {
                            pocket.setDepthBlend(document.getElementById('depthBlend').value,
                              document.getElementById('depthParam').value,
                              document.getElementById('blendSrcParam').value,
                              document.getElementById('blendDestParam').value);
                            };
                        }
                    }
                }

            function godsMain(screenWidth,screenHeight) {
                printLog("Main");

                /* Draw the fps                                  */
                drawFPS(screenWidth,screenHeight);

                /* Draw the developer tool bar                   */
                drawDevToolBar(screenWidth,screenHeight);

                /* Draw the canvas                               */
                drawCanvas(screenWidth,screenHeight);

                /* Begin WEBGL Render                            */
                webGLStart();

                }
        </script>
    </head>
    <body bgcolor = "black">
        <script>
            /* Calculate Width and Height before rendering       */
            var screenWidth = document.body.clientWidth  - 10;
            if (document.body.clientHeight > document.documentElement.clientHeight) {
                var screenHeight = document.body.clientHeight - 40;
                }
            else {
                var screenHeight = document.documentElement.clientHeight - 40;
                }

            printLog("Script Start");
            printLog("  Screen Width:"  + screenWidth);
            printLog("  Screen Height:" + screenHeight);
            godsMain(screenWidth,screenHeight);
        </script>
    </body>
</html>
